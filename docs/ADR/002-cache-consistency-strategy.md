# ADR-002: 缓存一致性策略选择

## 状态
已采纳 (2024-12-05)

## 背景
生鲜电商系统中，商品库存信息需要在高并发场景下快速读取，同时需要保证数据的相对准确性。系统涉及两个更新路径：
1. **高频读取路径**: 用户浏览商品，查看库存状态
2. **低频更新路径**: 运营后台修改商品库存数量

需要在MySQL(持久化存储)和Redis(缓存层)之间建立一致性机制。

## 决策
选择**双写策略(Write-Through) + 补偿任务**，而不是Cache-Aside模式或CDC(Change Data Capture)方案。

## 考虑的备选方案

### 方案A: Cache-Aside模式
- **流程**: 先删除缓存，再更新数据库
- **优势**: 实现简单，业界标准实践
- **劣势**: 存在缓存穿透窗口，高并发下可能导致数据库压力激增
- **适用场景**: 读多写少的场景

### 方案B: CDC方案(Canal/Debezium)
- **流程**: 监听MySQL binlog，异步更新Redis
- **优势**: 完全解耦，数据最终一致性可靠
- **劣势**: 架构复杂，运维成本高，学习成本大
- **适用场景**: 大规模分布式系统

### 方案C: 双写策略 + 补偿(选中)
- **流程**: 先更新数据库，再更新缓存，失败时触发补偿任务
- **优势**: 实现简单，大部分情况下强一致性
- **劣势**: 存在短暂不一致窗口
- **适用场景**: 中等规模系统，容忍短期不一致

## 决策依据

### 业务约束分析
- **数据敏感度**: 库存数据短暂不一致影响极小(用户下单时会二次校验)
- **更新频率**: 运营库存调整频率低(<10次/小时)
- **开发资源**: 单人开发，时间限制3个月
- **运维能力**: 不具备CDC组件运维经验

### 风险-收益评估
- **双写不一致窗口**: 5-10秒
- **业务损失评估**: 用户可能看到错误库存 → 下单时库存校验 → 几乎无损失  
- **开发投入**: 双写2小时 vs CDC方案2周
- **运维复杂度**: 双写 低 vs CDC 高

## 实现设计

### 核心流程
```java
@Transactional
public void updateInventory(Long productId, Integer newStock) {
    // 1. 更新数据库(主要数据源)
    inventoryRepository.updateStock(productId, newStock);
    
    // 2. 同步更新缓存
    try {
        String cacheKey = "inventory:" + productId;
        redisTemplate.opsForValue().set(cacheKey, newStock);
    } catch (Exception e) {
        // 3. 缓存更新失败，异步补偿
        log.error("Cache update failed for product {}", productId, e);
        taskService.submitCacheRefreshTask(productId);
    }
}
```

### 补偿机制
- **触发条件**: Redis写入异常、网络超时
- **补偿任务**: 通过数据库任务表异步执行
- **重试策略**: 指数退避，最大重试3次
- **监控告警**: 补偿任务失败时发送告警

### 读取优先级
1. **缓存命中**: 直接返回Redis数据
2. **缓存失效**: 查询数据库，同时预热缓存
3. **缓存异常**: 降级到数据库查询

## 后果

### 积极后果
✅ **开发效率**: 2小时完成vs2周学习+开发CDC  
✅ **运维简单**: 无额外组件，部署复杂度不变  
✅ **强一致性**: 90%+场景下数据实时一致  
✅ **故障隔离**: 缓存故障不影响核心业务  

### 消极后果
❌ **不一致窗口**: Redis更新失败时5-10秒数据不一致  
❌ **双写开销**: 每次更新需要两次写操作  
❌ **代码耦合**: 业务逻辑与缓存管理耦合  

### 风险控制
⚠️ **业务兜底**: 用户下单时从数据库二次校验库存  
⚠️ **监控告警**: 缓存更新失败率 > 1%时告警  
⚠️ **补偿可靠性**: 补偿任务基于可靠的数据库任务表  

## 数据不一致影响分析

### 场景1: 缓存更新失败
- **现象**: 用户看到旧的库存数量
- **持续时间**: 5-10秒(补偿任务执行)
- **业务影响**: 用户可能尝试购买已售罄商品
- **保护机制**: 下单时数据库库存校验，购买失败但无损失

### 场景2: 数据库更新成功，应用崩溃
- **现象**: 缓存与数据库不一致
- **持续时间**: 直到缓存TTL到期(1小时)或手动刷新
- **业务影响**: 同场景1
- **保护机制**: 同场景1 + 缓存定期刷新任务

## 演进触发条件
当满足以下条件时，考虑迁移到CDC方案:
1. 库存更新频率 > 100次/小时
2. 数据不一致业务投诉增加
3. 团队具备Canal/Debezium运维能力
4. 系统演进到微服务架构

## 监控指标
- 缓存更新成功率 (目标: >99%)
- 缓存-数据库一致性比率 (目标: >95%)
- 补偿任务执行频率 (目标: <10次/天)
- 库存校验失败率 (业务指标)

## 参考资料
- [Cache Patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)
- [Redis Best Practices](https://redis.io/docs/manual/patterns/)
- [Distributed Systems Consistency](https://jepsen.io/consistency)